@inject CurrentProblem problem
@inject QuickMathsConfig config
@inject ModuleState moduleState
@inject IJSRuntime JSRuntime

@inject Random random

<DialogBox>
    <p>Answer is @problem.answer</p>

</DialogBox>

<div class="problems-and-stats">
    <div class="horizontal-container stat-bar">
        <p>Time @(problem.timerTime / 60):@(problem.timerTime % 60)</p>
        <p>Correct @problem.correctCount</p>
    </div>
    <div class="horizontal-container">
        <img id="feedback-img" src="./public/correct/img_9855.jpg" alt="Cat with human hand showing thumbs up">
        <div class="equation">
            <p id="top-num">@problem.topNum</p>
            <p style="transform: translate(-@(longestNumberLength * 2.8)rem, 3.7rem)" id="operation">@problem.operation</p>
            <p id="bottom-num">@problem.bottomNum</p>
            <p style="width: @(longestNumberLength * 2.8)rem" id="line"></p>
            <p id="result">@problem.numpadInput</p>
        </div>
    </div>
    <button @onclick="RevealAnswer">Reveal Answer</button>
    <button @onclick="GenerateProblem">Skip</button>

    <audio id="correctAudio">
        <source src="./public/correct/yipe.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="incorrectAudio">
        <source src="./public/incorrect/sad-hamster.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
</div>

@code {
    private bool answerRevealed = false;
    private int longestNumberLength = 4;
    private async void RevealAnswer()
    {
        moduleState.Visible = true;
        answerRevealed = true;
        await JSRuntime.InvokeVoidAsync("incorrect");
    }
    private void GenerateProblem()
    {   
        problem.answer = "";
        problem.operation = config.selectedOperations[random.Next(config.selectedOperations.Count)];
        problem.numpadInput = "0";
        switch (problem.operation)
        {
            case "+":
                GenerateAdditionProblem();
                break;
            case "-":
                GenerateSubtractionProblem();
                break;
            case "ร":
                GenerateMultiplicationProblem();
                break;
            case "รท":
                GenerateDivisionProblem();
                break;
        }
        StateHasChanged();
    }

    private void GenerateAdditionProblem()
    {
        var topNum = getRandomNumBasedOnDifficulty();
        var bottomNum = getRandomNumBasedOnDifficulty();

        problem.topNum = $"{topNum}";
        problem.bottomNum = $"{bottomNum}";
        problem.answer = $"{topNum + bottomNum}";
    }

    private void GenerateSubtractionProblem()
    {
        var bottomNum = getRandomNumBasedOnDifficulty();
        var answer = getRandomNumBasedOnDifficulty();

        problem.bottomNum = $"{bottomNum}";
        problem.answer = $"{answer}";
        problem.topNum = $"{answer + bottomNum}";
    }

    private void GenerateMultiplicationProblem()
    {
        var topNum = getRandomNumBasedOnDifficulty();
        var bottomNum = getRandomNumBasedOnDifficulty(true);

        problem.topNum = $"{topNum}";
        problem.bottomNum = $"{bottomNum}";
        problem.answer = $"{topNum * bottomNum}";
    }

    private void GenerateDivisionProblem()
    {
        var bottomNum = getRandomNumBasedOnDifficulty(true);
        var answer = getRandomNumBasedOnDifficulty();

        problem.bottomNum = $"{bottomNum}";
        problem.answer = $"{answer}";
        problem.topNum = $"{bottomNum * answer}";
    }

    private int getRandomNumBasedOnDifficulty(bool limitRange = false)
    {
        if (limitRange)
        {
            return random.Next(10, 20);
        }
        switch (config.selectedDifficulty)
        {
            case "Normal":
                return random.Next(10, 100);
        }
        // Easy
        return random.Next(1, 10);
    }
    protected override void OnInitialized()
    {  
        GenerateProblem();
        problem.CurrentProblemStateChanged += OnProblemStateChanged;

    }
    public void Dispose()
    {
        problem.CurrentProblemStateChanged -= StateHasChanged;
    }
    public async void OnProblemStateChanged()
    {
        if (problem.numpadInput == problem.answer)
        {
            GenerateProblem();
            if (!answerRevealed)
            {
                problem.correctCount += 1;
                await JSRuntime.InvokeVoidAsync("correct");
            }
            else
            {
                answerRevealed = false;
            }
        }
        StateHasChanged();
    }
}